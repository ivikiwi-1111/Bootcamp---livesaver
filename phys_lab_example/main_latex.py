import numpy as np # Умные массивы и арифметические операции (многие функции из math модуля типа pow, sqrt доступны и в нём)
import pandas as pd # Большая библиотека для работы с данными, мы используем для быстрого импорта данных из файла excel или csv
import matplotlib.pyplot as plt # Графики
import matplotlib as mpl
from linear_least_squares import lin_ls # Функция для проведения прямой через экспериментальные точки методом МНК, формулы взятые из лабника по общей физике

data = pd.read_excel("data.xlsx", header=None).to_numpy() # Считываем файл в специфический формат и сразу же конвертируем его в numpy.array для дальнейшей работы
# data = pd.read_csv("data.csv").to_numpy() # Аналогично, если расширение файла .csv

#--------Проводим вычисления, необходимые в данной лабораторной работе--------#
r = (data[:, 2] + data[:, 1]) / 2 * 10 ** -3 # Считаем средний радиус колец по результатам двух измерений, записанных во 2-ую и 3-ю колонки файла
m = data[:, 0] # Создаем отдельный массив номеров колец

s_r = 4 * 10 ** -3 # Относительная погрешность измерения радиуса
sr_r = s_r / r # Абсолютная


y = r**2 # На графике будем откладывать квадрат радиуса
sr_y = 2 * sr_r # Абсолютная погрешность квадрата радиуса
s_y = y * sr_y # Относительная


(k, s_k) = lin_ls(m, y, through_null=True) # С помощью данной функции находим коэффициенты прямой (см. файл linear_least_squares.py), проходящей через эти точки

x_app = np.linspace(0, 8.5, 20) # Чтобы провести прямую задаём х, для которых будем вычислять y = k * x
y_app = k*x_app # Вычисляем y

# Строим график с крестами ошибок: так как у номеров колец погрешности нет, то параметр x_err для указания погрешности точек по оси х не прописываем
# Описание параметров: m, y - координаты точек на графике, y_err - погрешность по оси y, lw - толщина линии, так как обычно соседние точки не соединяют прямыми, то равна 0
# capsize - длина перпендикулярной палки креста ошибок (попробуйте поменять и сравнить графики до и после, возможно так нагляднее)
# capthick - её толщина, elinewidth - толщина вертикальной линии креста, figure - создаём фигуру с параметрами размера figsize в пикселях ((6, 6) - значит 600х600 пкс)
# и плотности точек на дюйм dpi - чтобы изображение не было размытым, в качестве маркера указываем кружок с пустым центром с диаметром ms=6 и толщиной линии кружка 1.5
er_plt = plt.errorbar(m, y, yerr=s_y, lw=0, capsize=3, capthick=1, elinewidth=1.5, figure=plt.figure(figsize=(6,6), dpi=200),
                              marker=mpl.markers.MarkerStyle("o", fillstyle="none"), ms=6, mew = 1.5)

# Строим прямую по вычисленным точкам, строка формата "-" указывает, что проводится сплошная линия 
# без маркеров (подробнее про строки форматов в разделе Notes тут https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html)
# с - сокращённо от color - цвет линии в формате RGB, linewidth - ширина линии
app = plt.plot(x_app, y_app, "-", c = [1, 0.5, 0], linewidth=2)


plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0), useMathText=True) # Масштаб в научном стиле без массы нулей с помощью отбражения степеней 10
# (попробуйте закомментировать строку чтобы увидеть разницу)
plt.ticklabel_format(style='sci', axis='x', scilimits=(0,0), useMathText=True)

plt.minorticks_on() # включаем мелкие деления (попробуйте отключить)
plt.grid(visible=True, which='major', linestyle='-', linewidth=1.5, color='0.7') # Формат основных линиий сетки
plt.grid(visible=True, which='minor', linestyle='--', linewidth=1, color='0.8') # Формат побочных линий, цвет указывается как оттенок серого - 0.0 - чёрный, 1.0 - белый
plt.rc('text', usetex=True) # Включаем использование latex для отображения любого текста на графике
plt.rc('text.latex', preamble=r'\usepackage[english, russian]{babel}') # Добавляем в преамбулу нужные пакеты

axis_lw = 2 # Константа для толщины осей
ax = plt.gca() # Чтобы задать параметры осей получаем сущность ax, через которую мы сможем к ним обратиться
ax.set_xlim([-0.3, 8.5]) # Пределы по оси х
ax.set_ylim([0, 5.9*10**-3]) # Пределы по оси y
ax.set_xlabel(r"$ m$") # Название оси х
ax.set_ylabel(r"$ r^2 $, м$^2$") # Название оси y

# Задаём некоторые параметры таким образом (попробуйте поменять)
plt.rc('axes', linewidth=axis_lw) # Толщина линий осей
plt.rc('xtick.major', width=axis_lw) # Тощина насечек по Ох
plt.rc('xtick.minor', width=0) # Отключаем побочные насечки по Ох
plt.rc('xtick', direction='in') # Направляем насечки по Ох внутрь графика
plt.rc('axes', labelsize=20) # Высота шрифта на названии осей
plt.rc('ytick.major', width=axis_lw) # Аналогично
plt.rc('ytick.minor', width=0)
plt.rc('ytick', direction='in')
plt.rc('xtick', labelsize=18) # Высота шрифта цифр масштаба
plt.rc('ytick', labelsize=18)
plt.rc('xtick.major', pad=10) # Отступ между осью и цифрами
plt.rc('ytick.major', pad=10)

# Легенда с автоматической подстановкой вычисленного значения коэффициента наклона прямой
k_fmt = ("%1.2e" % (k)).split("e-") # Представляем коэффициент k в виде массива, где первый элемент - число с одной значащей цифрой слева от запятой, второй - степень десяти
s_str = 'Аппроксимация: \n' + r"$r^2(m)$ " + '= \n$(' + k_fmt[0] + r"\pm" + ("%1.2f" % (s_k/k*float(k_fmt[0]))) + r")\cdot 10^{-" + f"{int(k_fmt[1])}" + r"}$" + r"$\cdot m$ " 
# print(s_str) # чтобы понять, что в итоге получается, можно сравнить с тем, что видно на графике

# Создаём легенду - сначала массив с линиями графиков (попробуйте поменять их местами), и подписями, соответствующими каждому,
# параметр loc определяет положение легенды на графике
ax.legend([er_plt, app[0]], ["Экспериментальные \n значения", s_str], loc=0)
plt.rc('legend', fontsize=16) # Размер шрифта легенды

plt.savefig("Images/plot_latex.png", bbox_inches='tight') # Сохраняем в файл


# Часто в лабах помимо получения значения коэффициента наклона прямой требуется провести
# с ним дальнейшие вычисления, их удобно провести прямо здесь (абстрактный пример):
    
g = 9.81
theta = k * g ** 2 / (2 * np.pi)
print(theta)
